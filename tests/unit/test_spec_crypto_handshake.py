"""
Handshake cryptography tests.

Tests keypair generation, key derivation, and handshake frame structures.
For full Noise_IK protocol tests, see tests/protocol/test_handshake_flow.py.

Test mapping: specs/1-SECURITY.md ยง "Handshake Protocol", "Session Key Derivation"
"""

from __future__ import annotations

from pathlib import Path

import json5
import pytest
from hypothesis import given, settings
from hypothesis import strategies as st
from nacl.bindings import crypto_scalarmult, crypto_scalarmult_base
from nacl.hash import blake2b

from lib.reference import (
    PRIVATE_KEY_SIZE,
    PUBLIC_KEY_SIZE,
    SESSION_ID_SIZE,
    deterministic_bytes,
    deterministic_keypair,
)

# =============================================================================
# Fixtures
# =============================================================================


@pytest.fixture(scope="module")
def handshake_vectors() -> dict:
    """Load handshake test vectors."""
    vectors_path = Path(__file__).parent.parent / "vectors" / "handshake_vectors.json5"
    with open(vectors_path) as f:
        return json5.load(f)


# =============================================================================
# Deterministic Keypair Generation
# =============================================================================


class TestDeterministicKeypair:
    """Test deterministic keypair generation for reproducible tests."""

    def test_keypair_from_seed(self) -> None:
        """Generate keypair from seed."""
        private, public = deterministic_keypair("test-seed")

        # Private key is derived from BLAKE2b (nacl returns hex-encoded)
        # The important thing is that it's deterministic and produces valid X25519 keys
        assert len(private) > 0
        assert len(public) == PUBLIC_KEY_SIZE

    def test_same_seed_same_keypair(self) -> None:
        """Same seed produces same keypair."""
        private1, public1 = deterministic_keypair("test-seed")
        private2, public2 = deterministic_keypair("test-seed")

        assert private1 == private2
        assert public1 == public2

    def test_different_seed_different_keypair(self) -> None:
        """Different seeds produce different keypairs."""
        private1, public1 = deterministic_keypair("seed-one")
        private2, public2 = deterministic_keypair("seed-two")

        assert private1 != private2
        assert public1 != public2

    def test_public_key_derived_from_private(self) -> None:
        """Public key is correctly derived from private key."""
        private, public = deterministic_keypair("derivation-test")

        # Manually derive public key
        derived_public = crypto_scalarmult_base(private)

        assert public == derived_public

    def test_vector_initiator_static(self, handshake_vectors: dict) -> None:
        """Initiator static keypair matches test vectors."""
        keypair = next(k for k in handshake_vectors["keypairs"] if k["name"] == "initiator_static")

        private, public = deterministic_keypair(keypair["seed"])

        assert public.hex() == keypair["public_key"]

    def test_vector_initiator_ephemeral(self, handshake_vectors: dict) -> None:
        """Initiator ephemeral keypair matches test vectors."""
        keypair = next(
            k for k in handshake_vectors["keypairs"] if k["name"] == "initiator_ephemeral"
        )

        private, public = deterministic_keypair(keypair["seed"])

        assert public.hex() == keypair["public_key"]

    def test_vector_responder_static(self, handshake_vectors: dict) -> None:
        """Responder static keypair matches test vectors."""
        keypair = next(k for k in handshake_vectors["keypairs"] if k["name"] == "responder_static")

        private, public = deterministic_keypair(keypair["seed"])

        assert public.hex() == keypair["public_key"]

    def test_vector_responder_ephemeral(self, handshake_vectors: dict) -> None:
        """Responder ephemeral keypair matches test vectors."""
        keypair = next(
            k for k in handshake_vectors["keypairs"] if k["name"] == "responder_ephemeral"
        )

        private, public = deterministic_keypair(keypair["seed"])

        assert public.hex() == keypair["public_key"]


# =============================================================================
# Deterministic Bytes Generation
# =============================================================================


class TestDeterministicBytes:
    """Test deterministic bytes generation for test data."""

    def test_deterministic_bytes_length(self) -> None:
        """Generated bytes have correct length."""
        data = deterministic_bytes("test-seed", 64)
        assert len(data) == 64

    def test_deterministic_bytes_various_lengths(self) -> None:
        """Various lengths work correctly."""
        for length in [1, 16, 32, 64, 100, 256]:
            data = deterministic_bytes("length-test", length)
            assert len(data) == length

    def test_same_seed_same_bytes(self) -> None:
        """Same seed produces same bytes."""
        data1 = deterministic_bytes("same-seed", 32)
        data2 = deterministic_bytes("same-seed", 32)

        assert data1 == data2

    def test_different_seed_different_bytes(self) -> None:
        """Different seeds produce different bytes."""
        data1 = deterministic_bytes("seed-one", 32)
        data2 = deterministic_bytes("seed-two", 32)

        assert data1 != data2

    def test_shorter_request_is_prefix(self) -> None:
        """Shorter length is prefix of longer length."""
        short = deterministic_bytes("prefix-test", 16)
        long = deterministic_bytes("prefix-test", 64)

        assert long[:16] == short


# =============================================================================
# X25519 Key Exchange
# =============================================================================


class TestX25519KeyExchange:
    """Test X25519 Diffie-Hellman key exchange."""

    def test_shared_secret_symmetric(self) -> None:
        """DH shared secret is symmetric (A*B = B*A)."""
        priv_a, pub_a = deterministic_keypair("alice")
        priv_b, pub_b = deterministic_keypair("bob")

        # Alice computes shared secret
        shared_a = crypto_scalarmult(priv_a, pub_b)

        # Bob computes shared secret
        shared_b = crypto_scalarmult(priv_b, pub_a)

        assert shared_a == shared_b

    def test_shared_secret_length(self) -> None:
        """Shared secret is 32 bytes."""
        priv_a, pub_a = deterministic_keypair("alice")
        priv_b, pub_b = deterministic_keypair("bob")

        shared = crypto_scalarmult(priv_a, pub_b)

        assert len(shared) == 32

    def test_different_parties_different_secrets(self) -> None:
        """Different key pairs produce different shared secrets."""
        priv_a, pub_a = deterministic_keypair("alice")
        priv_b, pub_b = deterministic_keypair("bob")
        priv_c, pub_c = deterministic_keypair("charlie")

        shared_ab = crypto_scalarmult(priv_a, pub_b)
        shared_ac = crypto_scalarmult(priv_a, pub_c)

        assert shared_ab != shared_ac


# =============================================================================
# Key Clamping
# =============================================================================


class TestKeyClamping:
    """Test X25519 private key clamping."""

    def test_private_key_is_clamped(self) -> None:
        """Private key has correct clamping bits set."""
        private, _ = deterministic_keypair("clamp-test")

        # X25519 clamping requirements:
        # - Clear bits 0, 1, 2 of first byte (divisible by 8)
        # - Clear bit 7 of last byte (< 2^255)
        # - Set bit 6 of last byte (>= 2^254)

        assert private[0] & 0x07 == 0  # Bits 0,1,2 clear
        assert private[31] & 0x80 == 0  # Bit 7 clear
        assert private[31] & 0x40 == 0x40  # Bit 6 set


# =============================================================================
# Handshake Frame Structure
# =============================================================================


class TestHandshakeInitStructure:
    """Test HandshakeInit frame structure per spec."""

    def test_handshake_init_type(self, handshake_vectors: dict) -> None:
        """HandshakeInit type is 0x01."""
        structure = handshake_vectors["handshake_init_structure"]
        type_field = next(f for f in structure["fields"] if f["name"] == "type")

        assert type_field["value"] == "01"
        assert type_field["offset"] == 0
        assert type_field["size"] == 1

    def test_handshake_init_reserved(self, handshake_vectors: dict) -> None:
        """HandshakeInit reserved byte is 0x00."""
        structure = handshake_vectors["handshake_init_structure"]
        reserved_field = next(f for f in structure["fields"] if f["name"] == "reserved")

        assert reserved_field["value"] == "00"
        assert reserved_field["offset"] == 1
        assert reserved_field["size"] == 1

    def test_handshake_init_version(self, handshake_vectors: dict) -> None:
        """HandshakeInit protocol version is 0x0001."""
        structure = handshake_vectors["handshake_init_structure"]
        version_field = next(f for f in structure["fields"] if f["name"] == "protocol_version")

        assert version_field["value"] == "0100"  # LE16
        assert version_field["decoded"] == 1
        assert version_field["offset"] == 2
        assert version_field["size"] == 2

    def test_handshake_init_ephemeral_offset(self, handshake_vectors: dict) -> None:
        """HandshakeInit ephemeral key at correct offset."""
        structure = handshake_vectors["handshake_init_structure"]
        ephemeral_field = next(f for f in structure["fields"] if f["name"] == "initiator_ephemeral")

        assert ephemeral_field["offset"] == 4
        assert ephemeral_field["size"] == 32

    def test_handshake_init_encrypted_static_offset(self, handshake_vectors: dict) -> None:
        """HandshakeInit encrypted static at correct offset."""
        structure = handshake_vectors["handshake_init_structure"]
        static_field = next(f for f in structure["fields"] if f["name"] == "encrypted_static")

        assert static_field["offset"] == 36
        assert static_field["size"] == 48  # 32 bytes + 16 tag

    def test_handshake_init_minimum_size(self, handshake_vectors: dict) -> None:
        """HandshakeInit minimum size is 100 bytes."""
        structure = handshake_vectors["handshake_init_structure"]

        assert structure["minimum_size"] == 100


class TestHandshakeRespStructure:
    """Test HandshakeResp frame structure per spec."""

    def test_handshake_resp_type(self, handshake_vectors: dict) -> None:
        """HandshakeResp type is 0x02."""
        structure = handshake_vectors["handshake_resp_structure"]
        type_field = next(f for f in structure["fields"] if f["name"] == "type")

        assert type_field["value"] == "02"
        assert type_field["offset"] == 0
        assert type_field["size"] == 1

    def test_handshake_resp_reserved(self, handshake_vectors: dict) -> None:
        """HandshakeResp reserved byte is 0x00."""
        structure = handshake_vectors["handshake_resp_structure"]
        reserved_field = next(f for f in structure["fields"] if f["name"] == "reserved")

        assert reserved_field["value"] == "00"
        assert reserved_field["offset"] == 1
        assert reserved_field["size"] == 1

    def test_handshake_resp_session_id(self, handshake_vectors: dict) -> None:
        """HandshakeResp session ID at correct offset."""
        structure = handshake_vectors["handshake_resp_structure"]
        session_id_field = next(f for f in structure["fields"] if f["name"] == "session_id")

        assert session_id_field["offset"] == 2
        assert session_id_field["size"] == SESSION_ID_SIZE

    def test_handshake_resp_ephemeral_offset(self, handshake_vectors: dict) -> None:
        """HandshakeResp ephemeral key at correct offset."""
        structure = handshake_vectors["handshake_resp_structure"]
        ephemeral_field = next(f for f in structure["fields"] if f["name"] == "responder_ephemeral")

        assert ephemeral_field["offset"] == 8
        assert ephemeral_field["size"] == 32

    def test_handshake_resp_minimum_size(self, handshake_vectors: dict) -> None:
        """HandshakeResp minimum size is 56 bytes."""
        structure = handshake_vectors["handshake_resp_structure"]

        assert structure["minimum_size"] == 56


# =============================================================================
# Session ID
# =============================================================================


class TestSessionID:
    """Test session ID generation and handling."""

    def test_session_id_size(self) -> None:
        """Session ID is 6 bytes."""
        assert SESSION_ID_SIZE == 6

    def test_deterministic_session_id(self) -> None:
        """Deterministic session ID for tests."""
        session_id = deterministic_bytes("session-id-test", SESSION_ID_SIZE)

        assert len(session_id) == 6

    def test_session_id_uniqueness(self) -> None:
        """Different seeds produce unique session IDs."""
        session_ids = set()
        for i in range(100):
            session_id = deterministic_bytes(f"session-{i}", SESSION_ID_SIZE)
            session_ids.add(session_id)

        assert len(session_ids) == 100


# =============================================================================
# Property-Based Tests
# =============================================================================


class TestKeyExchangeProperties:
    """Property-based tests for key exchange."""

    @given(seed_a=st.text(min_size=1, max_size=50), seed_b=st.text(min_size=1, max_size=50))
    @settings(max_examples=50)
    def test_dh_symmetric_property(self, seed_a: str, seed_b: str) -> None:
        """DH is symmetric for any key pairs."""
        priv_a, pub_a = deterministic_keypair(f"a-{seed_a}")
        priv_b, pub_b = deterministic_keypair(f"b-{seed_b}")

        shared_a = crypto_scalarmult(priv_a, pub_b)
        shared_b = crypto_scalarmult(priv_b, pub_a)

        assert shared_a == shared_b

    @given(seed=st.text(min_size=1, max_size=50))
    @settings(max_examples=50)
    def test_keypair_deterministic_property(self, seed: str) -> None:
        """Keypair generation is deterministic for any seed."""
        priv1, pub1 = deterministic_keypair(seed)
        priv2, pub2 = deterministic_keypair(seed)

        assert priv1 == priv2
        assert pub1 == pub2

    @given(seed=st.text(min_size=1, max_size=50))
    @settings(max_examples=50)
    def test_key_sizes_property(self, seed: str) -> None:
        """Key sizes are always correct for any seed."""
        private, public = deterministic_keypair(seed)

        # Private key derived from BLAKE2b - internal representation may vary
        assert len(private) > 0
        # Public key must always be 32 bytes for X25519
        assert len(public) == PUBLIC_KEY_SIZE


# =============================================================================
# BLAKE2b Hash (used in key derivation)
# =============================================================================


class TestBLAKE2b:
    """Test BLAKE2b hash used in key derivation.

    Note: nacl.hash.blake2b returns hex-encoded output by default,
    so a 32-byte digest becomes 64 hex characters (64 bytes).
    """

    def test_blake2b_digest_is_hex_encoded(self) -> None:
        """BLAKE2b returns hex-encoded digest (64 chars for 32-byte hash)."""
        digest = blake2b(b"test", digest_size=32)
        # nacl returns hex-encoded, so 32-byte digest = 64 hex chars = 64 bytes
        assert len(digest) == 64

    def test_blake2b_deterministic(self) -> None:
        """BLAKE2b is deterministic."""
        digest1 = blake2b(b"test", digest_size=32)
        digest2 = blake2b(b"test", digest_size=32)

        assert digest1 == digest2

    def test_blake2b_different_input_different_digest(self) -> None:
        """Different inputs produce different digests."""
        digest1 = blake2b(b"test1", digest_size=32)
        digest2 = blake2b(b"test2", digest_size=32)

        assert digest1 != digest2

    def test_blake2b_hex_encoding_consistent(self) -> None:
        """BLAKE2b hex encoding is consistent across digest sizes."""
        # All digest sizes are hex-encoded (double the byte size)
        for size in [16, 32, 64]:
            digest = blake2b(b"test", digest_size=size)
            # Hex encoding doubles the size
            assert len(digest) == size * 2


# =============================================================================
# Constants Validation
# =============================================================================


class TestSecurityConstants:
    """Validate security-related constants match spec."""

    def test_private_key_size(self) -> None:
        """Private key is 32 bytes."""
        assert PRIVATE_KEY_SIZE == 32

    def test_public_key_size(self) -> None:
        """Public key is 32 bytes."""
        assert PUBLIC_KEY_SIZE == 32

    def test_session_id_size(self) -> None:
        """Session ID is 6 bytes (48 bits)."""
        assert SESSION_ID_SIZE == 6
