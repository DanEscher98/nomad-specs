# NOMAD Security Layer Specification

**Parent:** [0-PROTOCOL.md](0-PROTOCOL.md)

---

## Overview

The security layer provides:
- Mutual authentication via Noise_IK handshake
- Authenticated encryption via XChaCha20-Poly1305
- Forward secrecy via periodic rekeying
- Identity hiding for initiator

---

## Handshake Protocol

NOMAD uses the **Noise_IK** pattern for 1-RTT mutual authentication.

### Prerequisites

- Initiator MUST know Responder's static public key beforehand (via SSH, QR code, etc.)
- Both parties MUST have static X25519 keypairs

### Noise_IK Pattern

```
Noise_IK(s, rs):
  <- s                    # Responder's static key known to Initiator
  ...
  -> e, es, s, ss         # Initiator sends ephemeral + encrypted static
  <- e, ee, se            # Responder sends ephemeral, completes DH
```

Where:
- `e` = ephemeral public key (32 bytes)
- `s` = static public key (encrypted after first DH)
- `es`, `ss`, `ee`, `se` = Diffie-Hellman operations mixed into symmetric state

---

## Handshake Initiation (Type 0x01)

Initiator → Responder

```mermaid
packet
  bitsPerRow 16
  +1: "Type 0x01"
  +1: "Reserved"
  +2: "Protocol Version"
  +32: "Initiator Ephemeral Public Key (32 bytes)"
  +48: "Encrypted Initiator Static (32 + 16 tag)"
  +16: "Encrypted Payload (min 16 tag)"
```

| Field | Offset | Size | Description |
|-------|--------|------|-------------|
| Type | 0 | 1 byte | `0x01` (HandshakeInit) |
| Reserved | 1 | 1 byte | `0x00` |
| Protocol Version | 2 | 2 bytes | `0x0001` for v1.0 (LE16) |
| Initiator Ephemeral | 4 | 32 bytes | Unencrypted X25519 public key |
| Encrypted Static | 36 | 48 bytes | Initiator's static key + AEAD tag |
| Encrypted Payload | 84 | variable | State type ID + extensions + AEAD tag |

**Minimum size:** 100 bytes (4 + 32 + 48 + 16)

### Encrypted Payload Contents

```mermaid
packet
  +8: "State Type ID Len"
  +120: "State Type ID (UTF-8)"
  +8: "Extension Count"
  +120: "Extensions (TLV)"
```

---

## Handshake Response (Type 0x02)

Responder → Initiator

```mermaid
packet
  +8: "Type 0x02"
  +8: "Reserved"
  +48: "Session ID (6 bytes)"
  +256: "Responder Ephemeral Public Key (32 bytes)"
  +128: "Encrypted Payload (min 16 tag)"
```

| Field | Offset | Size | Description |
|-------|--------|------|-------------|
| Type | 0 | 1 byte | `0x02` (HandshakeResp) |
| Reserved | 1 | 1 byte | `0x00` |
| Session ID | 2 | 6 bytes | Random identifier for this session (see §Session ID) |
| Responder Ephemeral | 8 | 32 bytes | Unencrypted X25519 public key |
| Encrypted Payload | 40 | variable | Ack + negotiated extensions + AEAD tag |

**Minimum size:** 56 bytes (8 + 32 + 16)

---

## Session Key Derivation

After successful handshake, both parties derive session keys:

```
(initiator_key, responder_key) = HKDF-Expand(
    handshake_hash,
    "nomad v1 session keys",
    64
)
```

| Party | Send Key | Receive Key |
|-------|----------|-------------|
| Initiator | `initiator_key` | `responder_key` |
| Responder | `responder_key` | `initiator_key` |

---

## Session ID

The 6-byte (48-bit) session ID is generated by the responder and used for frame demultiplexing.

### Generation

```python
def generate_session_id():
    return secure_random(6)  # 48 bits of randomness
```

### Collision Handling

With 48-bit session IDs, birthday paradox gives ~50% collision probability after 2^24 (~16 million) sessions.

Responders MUST:
1. Track active session IDs
2. Reject new sessions with colliding IDs
3. Generate new random ID on collision (retry up to 3 times)

```python
def create_session():
    for _ in range(3):
        session_id = generate_session_id()
        if session_id not in active_sessions:
            active_sessions.add(session_id)
            return session_id
    raise Error("session ID collision - too many active sessions")
```

---

## Handshake State Machine

### Retransmission

Handshake packets may be lost. Implementations MUST handle retransmission:

```mermaid
stateDiagram-v2
    [*] --> Idle
    Idle --> WaitResponse: send HandshakeInit
    WaitResponse --> WaitResponse: timeout / retransmit
    WaitResponse --> Established: recv HandshakeResp
    WaitResponse --> Idle: max retries exceeded
    Established --> [*]
```

### Timing Constants

| Constant | Value | Description |
|----------|-------|-------------|
| `HANDSHAKE_TIMEOUT` | 1000 ms | Initial retransmit timeout |
| `HANDSHAKE_MAX_RETRIES` | 5 | Maximum retransmission attempts |
| `HANDSHAKE_BACKOFF` | 2× | Exponential backoff multiplier |

### Initiator Retransmission

```python
def initiate_handshake():
    timeout = HANDSHAKE_TIMEOUT
    for attempt in range(HANDSHAKE_MAX_RETRIES):
        send(handshake_init)
        if wait_for_response(timeout):
            return success
        timeout = min(timeout * 2, 30000)  # Cap at 30s
    return failure
```

### Responder Behavior

Responders MUST be stateless until HandshakeInit is verified:
- Process duplicate HandshakeInit by regenerating HandshakeResp
- Do NOT allocate session state until crypto verification succeeds

---

## AEAD Encryption

All post-handshake frames use XChaCha20-Poly1305 AEAD.

### Nonce Construction (24 bytes)

```mermaid
packet
  +32: "Epoch (4 bytes)"
  +8: "Direction"
  +88: "Zeros (11 bytes)"
  +64: "Counter (8 bytes)"
```

| Field | Value |
|-------|-------|
| Epoch | Current epoch number, starts at 0 |
| Direction | `0x00` = Initiator→Responder, `0x01` = Responder→Initiator |
| Zeros | Padding |
| Counter | Per-direction frame counter, starts at 0 |

### Additional Authenticated Data (AAD)

The frame header is authenticated but not encrypted. This prevents bit-flipping attacks on header fields.

**AAD structure (exactly 16 bytes):**

| Offset | Size | Field |
|--------|------|-------|
| 0 | 1 | Frame type |
| 1 | 1 | Flags |
| 2 | 6 | Session ID |
| 8 | 8 | Nonce counter (LE64) |

```
AAD = type || flags || session_id || nonce_counter
```

Implementations MUST verify the AAD matches the frame header exactly.

---

## Rekeying (Type 0x04)

Sessions MUST rekey periodically for forward secrecy.

### Timing Constants

| Constant | Value | Description |
|----------|-------|-------------|
| `REKEY_AFTER_TIME` | 120 seconds | Initiate rekey after this time |
| `REKEY_AFTER_MESSAGES` | 2^60 | Initiate rekey after this many frames |
| `REJECT_AFTER_TIME` | 180 seconds | Hard limit, reject old keys |
| `REJECT_AFTER_MESSAGES` | 2^64 - 1 | **HARD LIMIT** - MUST terminate session |
| `OLD_KEY_RETENTION` | 5 seconds | Keep old keys after rekey for late packets |

### Counter Exhaustion

> ⚠️ **CRITICAL**: Nonce reuse with the same key is **catastrophic** for AEAD security.

Implementations MUST enforce hard limits:

```python
def send_frame():
    if send_nonce >= REJECT_AFTER_MESSAGES:
        terminate_session("counter exhaustion")
        return

    # ... proceed with encryption
```

If counter reaches `2^64 - 1`, the session MUST be terminated immediately. Do NOT wrap the counter.

### Rekey Frame Format

Encrypted with current session keys:

```mermaid
packet
  +8: "Type 0x04"
  +8: "Flags"
  +48: "Session ID"
  +64: "Nonce Counter"
  +256: "New Ephemeral (32 bytes, enc)"
  +32: "Timestamp (4 bytes, enc)"
  +128: "AEAD Tag (16 bytes)"
```

### Rekey Procedure

```mermaid
sequenceDiagram
    participant I as Initiator
    participant R as Responder

    Note over I: REKEY_AFTER_TIME elapsed
    I->>R: Rekey frame (new ephemeral)
    R->>I: Rekey response (responder ephemeral)

    Note over I,R: Derive new session keys
    Note over I,R: Increment epoch
    Note over I,R: Reset nonce counters to 0
    Note over I,R: Retain old keys for OLD_KEY_RETENTION
    Note over I,R: Zero old keys after retention period
```

### Key Transition

During rekey, briefly retain old keys to handle in-flight packets:

```python
def on_rekey_complete(new_keys):
    old_keys = current_keys
    current_keys = new_keys
    current_epoch += 1
    send_nonce = 0
    recv_nonce = 0

    # Retain old keys briefly for late packets
    schedule_zero(old_keys, delay=OLD_KEY_RETENTION)

def decrypt_frame(frame):
    # Try current epoch first
    if try_decrypt(frame, current_keys):
        return success

    # Fall back to old keys if within retention window
    if old_keys and within_retention_window():
        if try_decrypt(frame, old_keys):
            return success  # Late packet from old epoch

    return failure
```

### Post-Rekey Keys

```
(new_initiator_key, new_responder_key) = HKDF-Expand(
    new_handshake_hash,
    "nomad v1 rekey" || LE32(epoch),
    64
)
```

---

## Anti-Replay Protection

Implementations MUST maintain a sliding window of received nonces.

| Parameter | Value |
|-----------|-------|
| Window size | 2048 bits minimum |
| Below window | MUST reject |
| Seen nonce | MUST reject |
| Above highest | Update window |

### Replay Check Ordering

> **Performance**: Replay check MUST occur **BEFORE** AEAD verification.

```python
def receive_frame(frame):
    nonce = parse_nonce(frame)

    # 1. Replay check FIRST (cheap, prevents DoS via AEAD computation)
    if is_replay(nonce):
        drop_silently()
        return

    # 2. AEAD verification (expensive)
    if not verify_aead(frame):
        drop_silently()
        return

    # 3. Update replay window only after successful verification
    mark_seen(nonce)
    process_frame(frame)
```

This ordering prevents CPU exhaustion attacks where an attacker floods replayed packets to force expensive AEAD operations.

### Epoch Protection

Epoch numbers MUST NOT wrap:

```python
MAX_EPOCH = 2^32 - 1

def initiate_rekey():
    if current_epoch >= MAX_EPOCH:
        terminate_session("epoch exhaustion")
        return
    # ... proceed with rekey
```

If epoch reaches `2^32 - 1`, terminate the session and establish a new one via fresh handshake.

---

## Security Properties

| Property | Provided | Mechanism |
|----------|----------|-----------|
| Confidentiality | ✅ | XChaCha20-Poly1305 AEAD |
| Integrity | ✅ | Poly1305 authentication tag |
| Authenticity | ✅ | Noise_IK mutual authentication |
| Forward secrecy | ✅ | Ephemeral keys + 2-minute rekeying |
| Replay protection | ✅ | Nonce counter + sliding window |
| Identity hiding (initiator) | ✅ | Static key encrypted under responder's key |
| Identity hiding (responder) | ❌ | Responder's public key must be known |

---

## Implementation Requirements

Implementations MUST:

1. Use constant-time comparison for all secret-dependent operations
2. Zero memory containing keys when no longer needed
3. Use cryptographically secure RNG for all random values
4. Validate all input lengths before processing
5. Reject frames with invalid AEAD tags without timing differences

Implementations SHOULD:

1. Add random delays (0-50ms) to keystroke-like input to resist timing analysis
2. Pad frames to fixed sizes when traffic analysis is a concern
3. Implement rate limiting on handshake attempts
4. Log security-relevant events

---

## Test Vectors

See `tests/vectors/handshake_vectors.json5` for:
- Valid handshake initiation messages
- Valid handshake response messages
- Session key derivation test cases
- AEAD encryption test cases
- Rekey test cases

---

## Formal Verification

The security layer has been formally verified using ProVerif and TLA+.

### ProVerif Models

| Model | Properties Verified |
|-------|---------------------|
| `formal/proverif/nomad_handshake.pv` | Noise_IK authentication, key secrecy, identity hiding |
| `formal/proverif/nomad_rekey.pv` | Forward secrecy, post-compromise security |
| `formal/proverif/nomad_replay.pv` | Replay protection, nonce uniqueness |

### TLA+ Specifications

| Spec | Properties Verified |
|------|---------------------|
| `formal/tlaplus/RekeyStateMachine.tla` | Key rotation correctness, epoch management, counter limits |

### Verified Security Properties

All security properties listed in §Security Properties have been formally verified:

| Property | Verification Tool | Result |
|----------|-------------------|--------|
| Confidentiality | ProVerif | ✅ Proven |
| Authenticity | ProVerif | ✅ Proven |
| Forward secrecy | ProVerif + TLA+ | ✅ Proven |
| Replay protection | ProVerif | ✅ Proven |
| Identity hiding (initiator) | ProVerif | ✅ Proven |

See `formal/README.md` for instructions on running the verification tools.

---

## Test Mapping

| Spec Section | Test File |
|--------------|-----------|
| Handshake | `tests/protocol/test_handshake.py` |
| Handshake retransmission | `tests/protocol/test_handshake_retransmit.py` |
| Session ID collision | `tests/protocol/test_session_id.py` |
| AEAD | `tests/unit/test_crypto.py` |
| Nonce construction | `tests/unit/test_nonce.py` |
| Counter exhaustion | `tests/unit/test_counter_limits.py` |
| Rekeying | `tests/protocol/test_rekeying.py` |
| Key transition | `tests/protocol/test_key_transition.py` |
| Anti-replay | `tests/protocol/test_replay_rejection.py` |
| Epoch exhaustion | `tests/protocol/test_epoch_limits.py` |
| Invalid auth | `tests/adversarial/test_invalid_auth.py` |
